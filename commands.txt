python.exe pacman.py
python.exe pacman.py --layout testMaze --pacman GoWestAgent
python.exe pacman.py --layout tinyMaze --pacman GoWestAgent
python.exe pacman.py -h
python.exe pacman.py -l tinyMaze -p SearchAgent -a fn=tinyMazeSearch
python.exe pacman.py -l tinyMaze -p SearchAgent
python.exe pacman.py -l mediumMaze -p SearchAgent
python.exe pacman.py -l bigMaze -z .5 -p SearchAgent
python.exe pacman.py -l mediumMaze -p SearchAgent -a fn=bfs
python.exe pacman.py -l bigMaze -p SearchAgent -a fn=bfs -z .5
python.exe eightpuzzle.py
python.exe pacman.py -l mediumMaze -p SearchAgent -a fn=ucs
python.exe pacman.py -l mediumDottedMaze -p StayEastSearchAgent
python.exe pacman.py -l mediumScaryMaze -p StayWestSearchAgent
python.exe pacman.py -l bigMaze -z .5 -p SearchAgent -a fn=astar,heuristic=manhattanHeuristic 
python.exe pacman.py -l tinyCorners -p SearchAgent -a fn=bfs,prob=CornersProblem
python.exe pacman.py -l mediumCorners -p SearchAgent -a fn=bfs,prob=CornersProblem
python.exe pacman.py -l mediumCorners -z .5 -p SearchAgent -a fn=astar,heuristic=cornerVisibilityHeuristic,prob=CornersProblem
python.exe pacman.py -l mediumCornersKnight -p SearchAgent -a fn=bfs,prob=CornersHorseProblem
python.exe pacman.py -l mediumCorners -p AStarCornersAgent -z 0.5
python.exe pacman.py -l testSearch -p AStarFoodSearchAgent
python.exe pacman.py -l trickySearch -p AStarFoodSearchAgent
python.exe pacman.py -l bigSearch -p ClosestDotSearchAgent -z .5 
python.exe pacman.py -l bigSearch -p ApproximateSearchAgent -z .5 -q 



   #def getSuccessors(self, state):
        # successors = []
        # currentPosition, visited = state  # Extract current position and visited corners
        #
        # directions_diagonally = [
        #     Directions.NORTHWEST,
        #     Directions.SOUTHEAST,
        #     Directions.NORTHEAST,
        #     Directions.SOUTHWEST
        # ]
        #
        # directions_mapping = {
        #     Directions.NORTHWEST: [Directions.NORTH, Directions.WEST],
        #     Directions.SOUTHEAST: [Directions.SOUTH, Directions.EAST],
        #     Directions.NORTHEAST: [Directions.NORTH, Directions.EAST],
        #     Directions.SOUTHWEST: [Directions.SOUTH, Directions.WEST]
        # }
        #
        # corner_indices = {corner: i for i, corner in enumerate(self.corners)}
        #
        # for action_diagonal in directions_diagonally:
        #     dx, dy = Actions.directionToVector(action_diagonal)
        #     x, y = currentPosition
        #     nextx, nexty = int(x + dx), int(y + dy)
        #
        #     if 0 < nextx < self.walls.width - 2 and 0 < nexty < self.walls.height - 2 and not self.walls[nextx][nexty]:
        #         nextPosition = (nextx, nexty)
        #         nextVisited = list(visited)
        #
        #         if nextPosition in corner_indices:
        #             corner_index = corner_indices[nextPosition]
        #             if not nextVisited[corner_index]:
        #                 nextVisited[corner_index] = True
        #
        #         nextState = (nextPosition, nextVisited)
        #         aux = (nextState, action_diagonal, 2)
        #
        #         for action in directions_mapping.get(action_diagonal, []):
        #             dx, dy = Actions.directionToVector(action)
        #             nextx, nexty = int(nextx + dx), int(nexty + dy)
        #
        #             if 0 < nextx < self.walls.width - 2 and 0 < nexty < self.walls.height - 2 and not self.walls[nextx][
        #                 nexty]:
        #                 nextPosition = (nextx, nexty)
        #                 nextVisited = list(visited)
        #
        #                 if nextPosition in corner_indices:
        #                     corner_index = corner_indices[nextPosition]
        #                     if not nextVisited[corner_index]:
        #                         nextVisited[corner_index] = True
        #
        #                 nextState = (nextPosition, nextVisited)
        #                 successors.append(aux)
        #                 successors.append((nextState, action, 1))
        #                 print(aux + (nextState, action, 1))
        #
        # self._expanded += 1
        # return successors

------------------------------------------------------------------------------------------------------------------------
    def getSuccessors(self, state):
        """
        Returns successor states, the actions they require, and a cost of 1.

         As noted in search.py:
            For a given state, this should return a list of triples, (successor,
            action, stepCost), where 'successor' is a successor to the current
            state, 'action' is the action required to get there, and 'stepCost'
            is the incremental cost of expanding to that successor
        """
        successors = []
        currentPosition, visited = state  # Extract current position and visited corners

        directions_diagonally = [
            Directions.NORTHWEST,
            Directions.SOUTHEAST,
            Directions.NORTHEAST,
            Directions.SOUTHWEST
        ]

        directions_mapping = {
            Directions.NORTHWEST: [Directions.NORTH, Directions.WEST],
            Directions.SOUTHEAST: [Directions.SOUTH, Directions.EAST],
            Directions.NORTHEAST: [Directions.NORTH, Directions.EAST],
            Directions.SOUTHWEST: [Directions.SOUTH, Directions.WEST]
        }

        corner_indices = {corner: i for i, corner in enumerate(self.corners)}

        for action_diagonal in directions_diagonally:
            dx, dy = Actions.directionToVector(action_diagonal)
            x, y = currentPosition
            nextx, nexty = int(x + dx), int(y + dy)

            if 0 < nextx < self.walls.width - 2 and 0 < nexty < self.walls.height - 2 and not self.walls[nextx][nexty]:
                nextPosition = (nextx, nexty)
                nextVisited = list(visited)

                if nextPosition in corner_indices:
                    corner_index = corner_indices[nextPosition]
                    if not nextVisited[corner_index]:
                        nextVisited[corner_index] = True

                nextState = (nextPosition, nextVisited)
                aux = (nextState, action_diagonal, 2)

                for action in directions_mapping.get(action_diagonal, []):
                    dx, dy = Actions.directionToVector(action)
                    nextx, nexty = int(nextx + dx), int(nexty + dy)

                    if 0 < nextx < self.walls.width - 2 and 0 < nexty < self.walls.height - 2 and not self.walls[nextx][
                        nexty]:
                        nextPosition = (nextx, nexty)
                        nextVisited = list(visited)

                        if nextPosition in corner_indices:
                            corner_index = corner_indices[nextPosition]
                            if not nextVisited[corner_index]:
                                nextVisited[corner_index] = True
                                print(aux)

                        nextState = (nextPosition, nextVisited)
                        successors.append(aux)
                        successors.append((nextState, action, 1))

        self._expanded += 1
        return successors

-----------------------------------------------------------------------------------------------------------------------
            WORKING BUT NOT KNIGHT SHAPE
 def getSuccessors(self, state):
        successors = []
        currentPosition, visited = state

        corner_indices = {corner: i for i, corner in enumerate(self.corners)}

        # Define cardinal and diagonal directions
        cardinal_directions = [Directions.NORTH, Directions.SOUTH, Directions.EAST, Directions.WEST]
        diagonal_directions = [Directions.NORTHWEST, Directions.NORTHEAST, Directions.SOUTHWEST, Directions.SOUTHEAST]

        for action in cardinal_directions + diagonal_directions:
            dx, dy = Actions.directionToVector(action)
            x, y = currentPosition
            nextx, nexty = int(x + dx), int(y + dy)

            if (nextx, nexty) in corner_indices:
                corner_index = corner_indices[(nextx, nexty)]
                if corner_index not in visited:
                    new_visited = set(visited)
                    new_visited.add(corner_index)
                    nextState = ((nextx, nexty), new_visited)
                    cost = 1 if action in cardinal_directions else 2  # Adjust cost for diagonal moves
                    successors.append((nextState, action, cost))  # Ensure action is not a list

            if 0 < nextx < self.walls.width - 2 and 0 < nexty < self.walls.height - 2 and not self.walls[nextx][nexty]:
                nextState = ((nextx, nexty), visited)
                cost = 1 if action in cardinal_directions else 2  # Adjust cost for diagonal moves
                successors.append((nextState, action, cost))  # Ensure action is not a list

        self._expanded += 1
        return successors

